# C-mnius Compiler

**a Python3 based one-pass compiler for a very simplified C-minus**

## Token Types and Grammar

The tokens in the below table can be recognized by the compiler:
**Token Type** | **Description**
:-------------:|:--------------:
NUM | Any string matching [0-9]+
ID | Any string matching: [A-Za-z][A-Za-z0-9]*
KEYWORD | if, else, void, int, while, break, switch, default, case, return
SYMBOL | ; : , [ ] ( ) { } + - * = < ==
COMMENT | Any string between a /* and a */ OR any string after a // and before a \n or EOF
WHITESPACE | blank (ASCII 32), \n (ASCII 10), \r (ASCII 13), \t (ASCII 9), \v (ASCII 11), \f (ASCII 12)

The grammar that this compiler uses is in [grammar.txt](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/data/grammar.txt).

## First Phase : Scanner
Scanner is the part of the compiler that reads the input file character by character and recognizes tokens.
In this project, the preassumption is that a file called "input.txt" contains the code and is in the same directory as [compiler.py](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/compiler.py).
If only this phase is implemented, there should be while in [compiler.py](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/compiler.py) that calls a function in [scanner.py](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/scanner/scanner.py#L16) (get_next_token()) to read the next token from input file; in next phases this function is called by parser. 

## Tables
Error Table for lexical errors, Token Table and Symbol Table and additional information can be found in [tables folder](https://github.com/ArshiAAkhavan/C-minus-compiler/tree/master/tables).

## Second Phase : Parser
Parser is the part of the compiler that recognizes the grammar used by the input.

In this project we have a [LL1 class](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py#L9) that generates the parse table from the grammar and after that by using the function [generate_parse_tree](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py#L45) parses the input and creates a parse tree that can be printed. This class is also able to recognize different errors by using [panic](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py#L74) and [add_error](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py#L34) functions depending on where the error in generating parse tree happened. You can view the syntax errors and parse tree by calling [export_syntax_error](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py#L113) and [export_parse_tree](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py#L120). In order to create the parse tree [anytree library](https://github.com/c0fec0de/anytree) was used.

### Grammar
[parser.py](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/parser.py) generates the parse table using an instance of [grammar class](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L32). The grammar class reads the information of the grammar(first, follow, rules, predict sets)
from the [data folder](https://github.com/ArshiAAkhavan/C-minus-compiler/tree/master/Parser/data). Note that this works only after making instances of [Terminal](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L1) and [NonTerminal](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L11) classes that are terminals and non-terminals used by the grammar.
## Test
The file [test_scanner.py](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/tests/scanner/test.py) uses the samples folder to see if the expected outputs are generated by scanner and reports the results in log.
The file [test_parser.py](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/tests/parser/test.py) does the same for parser.
In order for this files to work correctly the working directory for them has to be changed to the project folder not the folder they are currently in.
## How to Use
### Scanner
Information on how to use and personaliza Scanner can be found [here](https://github.com/ArshiAAkhavan/C-minus-compiler/edit/master/scanner/README.md).
### Parser
This project is an LL1 parser so you can use this project if you have an LL1 grammar. First you should modify the [init_terminals](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L87) and [init_non_terminals](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L95) to containt the elements of your grammar. Then you have to replace the 4 files containing Firsts, Follows, Rules and predic sets in [data folder](https://github.com/ArshiAAkhavan/C-minus-compiler/tree/master/Parser/data). Please note the current formatting of the files or if you want to use a different format modify the import functions starting from [here](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L42) to make sure they work correctly.

The parser will work if you do not provide the first sets as well but make sure to remove [this line](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L118).

Here is a simple example:

```
E -> id * id $
```

The above will be the content of [grammar.txt](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/data/grammar.txt).

For the other files we have:

```
Firsts.txt:

E id

Follow.txt:

E

Predicts.txt:

id
```
You can calculate the first, follow and predic sets of your grammar using [this tool](https://mikedevice.github.io/first-follow/).

You also have to modify the [init_terminals](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L87) and [init_non_terminals](https://github.com/ArshiAAkhavan/C-minus-compiler/blob/master/Parser/grammar.py#L95) as shown bellow:

```python
def init_terminals():
    return [Terminal('$'), Terminal('id'), Terminal('*')]

def init_non_terminals():
    return [NonTerminal('E')]
```
